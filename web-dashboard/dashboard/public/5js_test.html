<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Draw → SVG → Animate</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <style>
    body { font-family: system-ui, sans-serif; padding: 12px; margin: 0; background: #1a1a1a; color: #eee; }
    .toolbar { display: flex; gap: 8px; align-items: center; margin-bottom: 8px; flex-wrap: wrap; }
    button { padding: 8px 14px; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; }
    button.primary { background: #4a9; color: #fff; }
    button.secondary { background: #444; color: #ddd; }
    button:hover { filter: brightness(1.1); }
    .paste-section { margin-bottom: 12px; }
    .paste-section label { display: block; font-size: 12px; color: #999; margin-bottom: 4px; }
    #pasteSvgTa { width: 100%; min-height: 100px; font-family: monospace; font-size: 11px; background: #222; color: #ddd; border: 1px solid #444; border-radius: 6px; padding: 8px; box-sizing: border-box; }
    #canvasContainer { margin-bottom: 16px; }
    #svgSection { margin-top: 20px; }
    #svgSection h3 { margin: 0 0 8px 0; font-size: 16px; }
    #svgPreview { background: #2a2a2a; border-radius: 8px; padding: 16px; min-height: 120px; }
    #svgPreview svg { max-width: 100%; max-height: 280px; display: block; }
    #svgPreview svg path { fill: none; stroke: #6cf; stroke-width: 2; stroke-linecap: round; stroke-linejoin: round; }
    .hint { font-size: 12px; color: #888; margin-top: 4px; }
    .tool-group { display: flex; align-items: center; gap: 4px; }
    .tool-group label { font-size: 12px; color: #999; }
    .color-swatch { width: 24px; height: 24px; border-radius: 50%; border: 2px solid transparent; cursor: pointer; }
    .color-swatch.active { border-color: #fff; box-shadow: 0 0 0 1px #1a1a1a; }
    .color-swatch:hover { transform: scale(1.1); }
  </style>
</head>
<body>
  <div class="toolbar">
    <div class="tool-group">
      <label>Tool</label>
      <button class="secondary tool-btn active" data-tool="pen">Pen</button>
      <button class="secondary tool-btn" data-tool="rect">Rectangle</button>
      <button class="secondary tool-btn" data-tool="circle">Circle</button>
      <button class="secondary tool-btn" data-tool="move">Move</button>
      <button class="secondary tool-btn" data-tool="transform">Transform</button>
    </div>
    <div class="tool-group">
      <label>Color</label>
      <div id="colorPalette"></div>
    </div>
    <button class="secondary" id="btnClear">Clear</button>
    <button class="primary" id="btnGroupAI">Group with AI</button>
    <button class="primary" id="btnExport">Export SVG &amp; Animate</button>
    <span id="groupStatus" class="hint" style="display: none;"></span>
    <span class="hint">Pen, Rect, Circle, Move, Transform. Group with AI then Export for rigging-ready SVG.</span>
  </div>
  <div class="paste-section">
    <label for="pasteSvgTa">Or paste existing SVG code (circles, rects, paths) and load:</label>
    <textarea id="pasteSvgTa" placeholder="Paste SVG here, e.g. &lt;svg&gt;...&lt;circle cx=.../&gt;...&lt;/svg&gt;"></textarea>
    <button type="button" class="secondary" id="btnLoadSvg" style="margin-top: 6px;">Load from SVG</button>
    <span id="pasteStatus" class="hint" style="display: none;"></span>
  </div>
  <div id="canvasContainer"></div>
  <div id="svgSection" style="display: none;">
    <h3>Exported SVG (animated)</h3>
    <div id="svgPreview"></div>
    <pre id="svgCode" style="margin: 8px 0 0 0; font-size: 11px; overflow: auto; max-height: 180px; background: #222; padding: 10px; border-radius: 6px;"></pre>
  </div>

  <script>
    let strokes = [];
    let shapes = [];
    let currentStroke = null;
    let currentTool = 'pen';
    let currentColor = [100, 200, 255];
    let dragStart = null;
    let selectedShapeIndex = null;
    let moveOffset = null;
    let transformSelectedIndex = -1;
    let transformHandle = null;
    let aiGroups = null;
    const HANDLE_SIZE = 10;
    let cw = 600, ch = 400;

    const PALETTE = [
      [100, 200, 255], [255, 100, 120], [100, 220, 140], [255, 200, 80],
      [180, 140, 255], [255, 255, 255], [60, 60, 80], [255, 150, 180]
    ];

    function setup() {
      // #region agent log
      const log = (msg, data, hid) => fetch('http://127.0.0.1:7242/ingest/b81179ea-362a-4b1e-9962-8572fc6e73fd',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'5js_test.html:setup',message:msg,data:data||{},timestamp:Date.now(),sessionId:'debug-session',hypothesisId:hid||'canvas'})}).catch(()=>{});
      const container = document.getElementById('canvasContainer');
      log('setup start', { hasContainer: !!container, cw, ch }, 'H1');
      // #endregion
      let canvas = createCanvas(cw, ch);
      // #region agent log
      log('after createCanvas', { width: width, height: height }, 'H2');
      // #endregion
      canvas.parent('canvasContainer');
      // #region agent log
      const parentEl = canvas.elt && canvas.elt.parentElement;
      log('after parent()', { parentId: parentEl ? parentEl.id : null }, 'H2');
      // #endregion
      background(28, 28, 28);

      document.querySelectorAll('.tool-btn').forEach(btn => {
        btn.onclick = () => {
          document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          currentTool = btn.dataset.tool;
          transformSelectedIndex = -1;
          transformHandle = null;
        };
      });

      const paletteEl = document.getElementById('colorPalette');
      PALETTE.forEach((col, i) => {
        let swatch = document.createElement('div');
        swatch.className = 'color-swatch' + (i === 0 ? ' active' : '');
        swatch.style.background = `rgb(${col[0]},${col[1]},${col[2]})`;
        swatch.onclick = () => {
          document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
          swatch.classList.add('active');
          currentColor = col;
        };
        paletteEl.appendChild(swatch);
      });

      document.getElementById('btnClear').onclick = () => {
        strokes = [];
        shapes = [];
        currentStroke = null;
        dragStart = null;
        selectedShapeIndex = null;
        moveOffset = null;
        transformSelectedIndex = -1;
        transformHandle = null;
        aiGroups = null;
        background(28, 28, 28);
        document.getElementById('svgSection').style.display = 'none';
        document.getElementById('groupStatus').style.display = 'none';
      };

      document.getElementById('btnGroupAI').onclick = async () => {
        let elements = buildElementsForAPI();
        if (elements.length === 0) {
          alert('Draw some shapes first.');
          return;
        }
        let btn = document.getElementById('btnGroupAI');
        let status = document.getElementById('groupStatus');
        btn.disabled = true;
        status.style.display = 'inline';
        status.textContent = 'Grouping...';
        try {
          let res = await fetch('/svg-api/group-svg', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ elements }),
          });
          let text = await res.text();
          let data = {};
          try { data = JSON.parse(text); } catch (_) {}
          // #region agent log
          fetch('http://127.0.0.1:7242/ingest/b81179ea-362a-4b1e-9962-8572fc6e73fd',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'5js_test.html:GroupAI',message:'group-svg response',data:{status:res.status,statusText:res.statusText,bodyError:data.error,textPreview:(text||'').slice(0,200),elementsCount:elements.length},timestamp:Date.now(),sessionId:'debug-session',hypothesisId:'server500'})}).catch(()=>{});
          // #endregion
          if (!res.ok) {
            status.textContent = 'Error: ' + (data.error || text.slice(0, 80) || res.statusText);
            return;
          }
          aiGroups = data.groups || null;
          let names = aiGroups ? Object.keys(aiGroups).join(', ') : '';
          status.textContent = names ? 'Grouped: ' + names : 'No groups returned';
        } catch (e) {
          // #region agent log
          fetch('http://127.0.0.1:7242/ingest/b81179ea-362a-4b1e-9962-8572fc6e73fd',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'5js_test.html:GroupAI catch',message:'fetch exception',data:{message:e.message},timestamp:Date.now(),sessionId:'debug-session',hypothesisId:'server500'})}).catch(()=>{});
          // #endregion
          status.textContent = 'Error: ' + e.message;
        } finally {
          btn.disabled = false;
        }
      };

      document.getElementById('btnExport').onclick = () => {
        if (strokes.length === 0 && shapes.length === 0) return;
        let svg = toSVG();
        let preview = document.getElementById('svgPreview');
        preview.innerHTML = svg;
        document.getElementById('svgCode').textContent = svg;
        document.getElementById('svgSection').style.display = 'block';
        animatePaths(preview.querySelector('svg'));
      };

      document.getElementById('btnLoadSvg').onclick = () => {
        let raw = (document.getElementById('pasteSvgTa').value || '').trim();
        let status = document.getElementById('pasteStatus');
        if (!raw) {
          status.style.display = 'inline';
          status.textContent = 'Paste SVG code first.';
          return;
        }
        shapes = [];
        strokes = [];
        aiGroups = null;
        let loaded = loadFromSvg(raw);
        status.style.display = 'inline';
        status.textContent = loaded ? `Loaded ${loaded} elements. Paths are in data but only circles/rects draw on canvas.` : 'No circle/rect/path found in pasted SVG.';
      };
    }

    function parseColorToRgb(cssColor) {
      if (!cssColor) return [100, 100, 100];
      let m = cssColor.match(/^#([0-9a-fA-F]{6})$/);
      if (m) {
        let h = m[1];
        return [parseInt(h.slice(0,2), 16), parseInt(h.slice(2,4), 16), parseInt(h.slice(4,6), 16)];
      }
      m = cssColor.match(/^#([0-9a-fA-F]{3})$/);
      if (m) {
        let h = m[1];
        return [parseInt(h[0]+h[0],16), parseInt(h[1]+h[1],16), parseInt(h[2]+h[2],16)];
      }
      m = cssColor.match(/rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/);
      if (m) return [parseInt(m[1],10), parseInt(m[2],10), parseInt(m[3],10)];
      return [100, 100, 100];
    }

    function loadFromSvg(svgString) {
      try {
        let parser = new DOMParser();
        let s = svgString.replace(/<\?xml[^>]*\?>\s*/i, '').trim();
        if (!s.includes('<svg')) s = '<svg xmlns="http://www.w3.org/2000/svg">' + s + '</svg>';
        let doc = parser.parseFromString(s, 'image/svg+xml');
        let svg = doc.querySelector('svg');
        if (!svg) svg = doc.documentElement;
        let count = 0;
        const loadOrder = [];
        const tagSet = new Set(['circle', 'rect', 'path']);
        for (let child of svg.children) {
          const tag = (child.tagName || '').toLowerCase();
          if (!tagSet.has(tag)) continue;
          if (tag === 'circle') {
            let cx = parseFloat(child.getAttribute('cx')) || 0;
            let cy = parseFloat(child.getAttribute('cy')) || 0;
            let r = parseFloat(child.getAttribute('r')) || 10;
            let fill = child.getAttribute('fill') || '#64dc8c';
            shapes.push({ type: 'circle', x: cx, y: cy, r, color: parseColorToRgb(fill) });
            loadOrder.push({ type: 'circle', fill });
            count++;
          } else if (tag === 'rect') {
            let x = parseFloat(child.getAttribute('x')) || 0;
            let y = parseFloat(child.getAttribute('y')) || 0;
            let w = parseFloat(child.getAttribute('width')) || 20;
            let h = parseFloat(child.getAttribute('height')) || 20;
            let fill = child.getAttribute('fill') || '#64dc8c';
            shapes.push({ type: 'rect', x, y, w, h, color: parseColorToRgb(fill) });
            loadOrder.push({ type: 'rect', fill });
            count++;
          } else if (tag === 'path') {
            let d = child.getAttribute('d');
            if (!d) continue;
            let stroke = child.getAttribute('stroke') || child.getAttribute('fill') || '#646464';
            shapes.push({ type: 'path', d, stroke, color: parseColorToRgb(stroke) });
            loadOrder.push({ type: 'path' });
            count++;
          }
        }
        // #region agent log
        fetch('http://127.0.0.1:7242/ingest/b81179ea-362a-4b1e-9962-8572fc6e73fd',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'5js_test.html:loadFromSvg',message:'load order',data:{count,loadOrder:loadOrder.slice(0,20)},timestamp:Date.now(),sessionId:'debug-session',hypothesisId:'zorder'})}).catch(()=>{});
        // #endregion
        return count;
      } catch (e) {
        console.error('loadFromSvg', e);
        return 0;
      }
    }

    function draw() {
      // #region agent log
      if (frameCount === 1) { fetch('http://127.0.0.1:7242/ingest/b81179ea-362a-4b1e-9962-8572fc6e73fd',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'5js_test.html:draw',message:'first frame',data:{frameCount:1},timestamp:Date.now(),sessionId:'debug-session',hypothesisId:'H3'})}).catch(()=>{}); return; }
      // #endregion
      background(28, 28, 28);
      shapes.forEach(s => {
        fill(s.color[0], s.color[1], s.color[2]);
        noStroke();
        if (s.type === 'rect') rect(s.x, s.y, s.w, s.h);
        else if (s.type === 'circle') ellipse(s.x, s.y, s.r * 2, s.r * 2);
      });
      strokes.forEach(s => {
        if (s.length < 2) return;
        let c = s[0].color || currentColor;
        stroke(c[0], c[1], c[2]);
        strokeWeight(3);
        noFill();
        for (let i = 1; i < s.length; i++) line(s[i - 1].x, s[i - 1].y, s[i].x, s[i].y);
      });
      if (currentStroke && currentStroke.length > 1) {
        stroke(currentColor[0], currentColor[1], currentColor[2]);
        strokeWeight(3);
        noFill();
        for (let i = 1; i < currentStroke.length; i++)
          line(currentStroke[i - 1].x, currentStroke[i - 1].y, currentStroke[i].x, currentStroke[i].y);
      }
      if (dragStart && (currentTool === 'rect' || currentTool === 'circle')) {
        fill(currentColor[0], currentColor[1], currentColor[2]);
        noStroke();
        if (currentTool === 'rect') {
          let x = min(mouseX, dragStart.x), y = min(mouseY, dragStart.y);
          let w = abs(mouseX - dragStart.x), h = abs(mouseY - dragStart.y);
          rect(x, y, w, h);
        } else if (currentTool === 'circle') {
          let r = dist(dragStart.x, dragStart.y, mouseX, mouseY);
          ellipse(dragStart.x, dragStart.y, r * 2, r * 2);
        }
      }
      if (currentTool === 'transform' && transformSelectedIndex >= 0) {
        let s = shapes[transformSelectedIndex];
        noFill();
        stroke(255, 220, 80);
        strokeWeight(1);
        if (s.type === 'rect') rect(s.x - 2, s.y - 2, s.w + 4, s.h + 4);
        else if (s.type === 'circle') ellipse(s.x, s.y, (s.r + 4) * 2, (s.r + 4) * 2);
        fill(255, 220, 80);
        noStroke();
        getHandlePositions(transformSelectedIndex).forEach(h => rect(h.x - HANDLE_SIZE/2, h.y - HANDLE_SIZE/2, HANDLE_SIZE, HANDLE_SIZE));
      }
    }

    function getHandlePositions(shapeIndex) {
      let s = shapes[shapeIndex];
      if (!s) return [];
      if (s.type === 'rect') return [
        { x: s.x, y: s.y }, { x: s.x + s.w, y: s.y }, { x: s.x + s.w, y: s.y + s.h }, { x: s.x, y: s.y + s.h }
      ];
      if (s.type === 'circle') return [
        { x: s.x + s.r, y: s.y }, { x: s.x, y: s.y + s.r }, { x: s.x - s.r, y: s.y }, { x: s.x, y: s.y - s.r }
      ];
      return [];
    }

    function hitTestHandle(px, py) {
      if (transformSelectedIndex < 0) return null;
      let handles = getHandlePositions(transformSelectedIndex);
      for (let i = 0; i < handles.length; i++) {
        let h = handles[i];
        if (px >= h.x - HANDLE_SIZE/2 && px <= h.x + HANDLE_SIZE/2 && py >= h.y - HANDLE_SIZE/2 && py <= h.y + HANDLE_SIZE/2)
          return { shapeIndex: transformSelectedIndex, handleId: i };
      }
      return null;
    }

    function hitTestShape(px, py) {
      for (let i = shapes.length - 1; i >= 0; i--) {
        let s = shapes[i];
        if (s.type === 'rect' && px >= s.x && px <= s.x + s.w && py >= s.y && py <= s.y + s.h) return i;
        if (s.type === 'circle' && dist(px, py, s.x, s.y) <= s.r) return i;
      }
      return -1;
    }

    function mousePressed() {
      if (mouseX < 0 || mouseX > width || mouseY < 0 || mouseY > height) return;
      if (currentTool === 'pen') {
        currentStroke = [{ x: mouseX, y: mouseY, color: [...currentColor] }];
        strokes.push(currentStroke);
      } else if (currentTool === 'move') {
        let i = hitTestShape(mouseX, mouseY);
        if (i >= 0) {
          let s = shapes[i];
          selectedShapeIndex = i;
          moveOffset = { x: mouseX - s.x, y: mouseY - s.y };
        }
      } else if (currentTool === 'transform') {
        let handleHit = hitTestHandle(mouseX, mouseY);
        if (handleHit) {
          transformHandle = handleHit;
        } else {
          let i = hitTestShape(mouseX, mouseY);
          transformSelectedIndex = i >= 0 ? i : -1;
        }
      } else {
        dragStart = { x: mouseX, y: mouseY };
      }
    }

    function mouseDragged() {
      if (currentTool === 'pen' && currentStroke) {
        currentStroke.push({ x: mouseX, y: mouseY });
      } else if (currentTool === 'move' && selectedShapeIndex !== null && moveOffset !== null) {
        let s = shapes[selectedShapeIndex];
        s.x = mouseX - moveOffset.x;
        s.y = mouseY - moveOffset.y;
      } else if (currentTool === 'transform' && transformHandle !== null) {
        let s = shapes[transformHandle.shapeIndex];
        if (s.type === 'rect') {
          let x2 = s.x + s.w, y2 = s.y + s.h;
          let x1 = s.x, y1 = s.y;
          if (transformHandle.handleId === 0) { x1 = mouseX; y1 = mouseY; }
          else if (transformHandle.handleId === 1) { x2 = mouseX; y1 = mouseY; }
          else if (transformHandle.handleId === 2) { x2 = mouseX; y2 = mouseY; }
          else if (transformHandle.handleId === 3) { x1 = mouseX; y2 = mouseY; }
          s.x = min(x1, x2); s.y = min(y1, y2);
          s.w = abs(x2 - x1); s.h = abs(y2 - y1);
          if (s.w < 4) s.w = 4;
          if (s.h < 4) s.h = 4;
        } else if (s.type === 'circle') {
          let r = dist(mouseX, mouseY, s.x, s.y);
          if (r >= 5) s.r = r;
        }
      }
    }

    function mouseReleased() {
      if (currentTool === 'rect' && dragStart) {
        let x = min(mouseX, dragStart.x), y = min(mouseY, dragStart.y);
        let w = abs(mouseX - dragStart.x), h = abs(mouseY - dragStart.y);
        if (w > 2 && h > 2) shapes.push({ type: 'rect', x, y, w, h, color: [...currentColor] });
        dragStart = null;
      } else if (currentTool === 'circle' && dragStart) {
        let r = dist(dragStart.x, dragStart.y, mouseX, mouseY);
        if (r > 2) shapes.push({ type: 'circle', x: dragStart.x, y: dragStart.y, r, color: [...currentColor] });
        dragStart = null;
      }
      if (currentTool === 'pen') currentStroke = null;
      if (currentTool === 'move') { selectedShapeIndex = null; moveOffset = null; }
      if (currentTool === 'transform') transformHandle = null;
    }

    function buildElementsForAPI() {
      const hex = (r, g, b) => '#' + [r, g, b].map(x => ('0' + x.toString(16)).slice(-2)).join('');
      let elements = [];
      shapes.forEach(s => {
        if (s.type === 'rect')
          elements.push({ type: 'rect', x: s.x, y: s.y, width: s.w, height: s.h, fill: hex(s.color[0], s.color[1], s.color[2]) });
        else if (s.type === 'circle')
          elements.push({ type: 'circle', cx: s.x, cy: s.y, r: s.r, fill: hex(s.color[0], s.color[1], s.color[2]) });
        else if (s.type === 'path')
          elements.push({ type: 'path', d: s.d, stroke: s.stroke || hex(s.color[0], s.color[1], s.color[2]) });
      });
      strokes.forEach(s => {
        if (s.length < 2) return;
        let d = `M ${s[0].x} ${s[0].y}`;
        for (let i = 1; i < s.length; i++) d += ` L ${s[i].x} ${s[i].y}`;
        let sc = s[0].color || currentColor;
        elements.push({ type: 'path', d, stroke: hex(sc[0], sc[1], sc[2]) });
      });
      return elements;
    }

    function toSVG() {
      const w = cw, h = ch;
      const hex = (r, g, b) => '#' + [r, g, b].map(x => ('0' + x.toString(16)).slice(-2)).join('');
      let indexToPart = [];
      shapes.forEach(s => {
        if (s.type === 'rect')
          indexToPart.push(`<rect x="${s.x}" y="${s.y}" width="${s.w}" height="${s.h}" fill="${hex(s.color[0], s.color[1], s.color[2])}" />`);
        else if (s.type === 'circle')
          indexToPart.push(`<circle cx="${s.x}" cy="${s.y}" r="${s.r}" fill="${hex(s.color[0], s.color[1], s.color[2])}" />`);
        else if (s.type === 'path')
          indexToPart.push(`<path d="${(s.d || '').replace(/"/g, '&quot;')}" fill="none" stroke="${s.stroke || hex(s.color[0], s.color[1], s.color[2])}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />`);
      });
      strokes.forEach(s => {
        if (s.length < 2) return;
        let d = `M ${s[0].x} ${s[0].y}`;
        for (let i = 1; i < s.length; i++) d += ` L ${s[i].x} ${s[i].y}`;
        let sc = s[0].color || currentColor;
        indexToPart.push(`<path d="${d}" fill="none" stroke="${hex(sc[0], sc[1], sc[2])}" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" />`);
      });
      let indexToGroup = null;
      if (aiGroups && Object.keys(aiGroups).length) {
        indexToGroup = {};
        for (let name of Object.keys(aiGroups))
          for (let i of aiGroups[name]) indexToGroup[i] = name;
      }
      let inner = indexToPart.map((part, i) => {
        let group = indexToGroup && indexToGroup[i];
        return group ? `<g id="${group}">\n    ${part}\n  </g>` : part;
      }).join('\n  ');
      return `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${w} ${h}" width="${w}" height="${h}">
  <g id="walkRoot">
  ${inner}
  </g>
</svg>`;
    }

    function animatePaths(svgEl) {
      if (!svgEl) return;
      let start = null;
      const duration = 2000;

      // Paths: draw-in effect (stroke-dashoffset) only
      let paths = svgEl.querySelectorAll('path');
      paths.forEach(p => {
        let len = p.getTotalLength();
        p.style.strokeDasharray = len;
        p.style.strokeDashoffset = len;
      });

      function step(ts) {
        if (!start) start = ts;
        let t = Math.min((ts - start) / duration, 1);
        let ease = 1 - (1 - t) * (1 - t);
        paths.forEach(p => {
          let len = p.getTotalLength();
          p.style.strokeDashoffset = len * (1 - ease);
        });
        if (t < 1) {
          requestAnimationFrame(step);
        } else {
          startWalk(svgEl);
        }
      }
      if (paths.length > 0) requestAnimationFrame(step);
      else startWalk(svgEl);
    }

    function startWalk(svgEl) {
      let walkRoot = svgEl.querySelector('#walkRoot');
      if (!walkRoot) return;
      const viewBoxWidth = 600;
      const bobAmplitude = 6;
      const bobFreq = 2;
      const driftSpeed = 40;
      let startTime = Date.now();
      function step() {
        let t = (Date.now() - startTime) / 1000;
        let x = (driftSpeed * t) % viewBoxWidth;
        let y = -bobAmplitude * Math.sin(2 * Math.PI * bobFreq * t);
        walkRoot.style.transform = `translate(${x}px, ${y}px)`;
        requestAnimationFrame(step);
      }
      requestAnimationFrame(step);
    }
  </script>
</body>
</html>
